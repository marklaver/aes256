		ArrayList<String> cleanText = cleanHex(text);
		AESa state = new AESa(cleanText.size());

		if (option == 'e') {
			for (int i = 0; i < plain_text.length; ++i) {
				plain_text[i] = hexToBin(cleanText.get(i));
			}
		}
		else if (option == 'd') {
			for (int i = 0; i < plain_text.length; ++i) {
				cipher_text[i] = hexToBin(cleanText.get(i));
			}			
		}

		print_array("key_orig", key);
		int [][] expanded_key = key_expansion(key);
		// System.out.println("expanded_key is: ");
		// print_array("Expaaanded key",expanded_key);
		
		if(option == 'e') {
			encrypt(expanded_key);
			writeFile(cipher_text, inputFile, 'e');
		}
		else if (option == 'd') {
			decrypt(expanded_key);
			writeFile(plain_text, inputFile, 'd');
		}
		else if (option == 't') {
			encrypt(expanded_key);
			writeFile(cipher_text, inputFile, 'e');
			decrypt(expanded_key);
			writeFile(plain_text, inputFile, 'd');
		}
		else
			System.out.println("Invalid flag.");

		// Encrypt




		// Decrypt

		// for (int row = 0; row < plain_text.length; ++row) {
		// 	setState(row, 'd');
		// 	addRoundKey(expanded_key,14);
		// 	invShiftRows();
		// 	invSubBytes();
			
		// 	for (int round = 13; round >= 1; --round) {
		// 		addRoundKey(expanded_key, round);
		// 		for (int i = 0; i < 4; ++i)
		// 			invMixColumn2(i);
		// 		invShiftRows();
		// 		invSubBytes();
		// 	}

  //     addRoundKey(expanded_key, 0);
		// }
	}

	static void encrypt(int[][] expanded_key) {
		for (int row = 0; row < plain_text.length; ++row) {
			setState(row, 'e');
			print_state("plaintext");
			addRoundKey(expanded_key, 0);

			for (int round = 1; round <= 13; ++round) {
				subBytes();
				shiftRows();
				for (int i = 0; i < 4; ++i)
					mixColumn2(i);
				addRoundKey(expanded_key, round);
				
			}

			subBytes();
			shiftRows();
			addRoundKey(expanded_key, 14);
			save_state(row, 'e');
		}
	}

	static void decrypt(int[][] expanded_key) {
		for (int row = 0; row < plain_text.length; ++row) {
			setState(row, 'd');
			addRoundKey(expanded_key,14);
			invShiftRows();
			invSubBytes();
			
			for (int round = 13; round >= 1; --round) {
				addRoundKey(expanded_key, round);
				for (int i = 0; i < 4; ++i)
					invMixColumn2(i);
				invShiftRows();
				invSubBytes();
			}

      addRoundKey(expanded_key, 0);
      save_state(row, 'd');
		}		
	}
